/**
 * 修改底层方法，解决缩放动画问题
*/
function simpleheat(t) { if (!(this instanceof simpleheat)) return new simpleheat(t); this._canvas = t = typeof t === 'string' ? document.getElementById(t) : t, this._ctx = t.getContext('2d'), this._width = t.width, this._height = t.height, this._max = 1, this._data = []; } typeof module !== 'undefined' && (module.exports = simpleheat), simpleheat.prototype = {
  defaultRadius: 25,
  defaultGradient: {
    0.4: 'blue', 0.6: 'cyan', 0.7: 'lime', 0.8: 'yellow', 1: 'red',
  },
  data(t) { return this._data = t, this; },
  max(t) { return this._max = t, this; },
  add(t) { return this._data.push(t), this; },
  clear() { return this._data = [], this; },
  radius(t, i) { i = void 0 === i ? 15 : i; const a = this._circle = this._createCanvas(); const e = a.getContext('2d'); const s = this._r = t + i; return a.width = a.height = 2 * s, e.shadowOffsetX = e.shadowOffsetY = 2 * s, e.shadowBlur = i, e.shadowColor = 'black', e.beginPath(), e.arc(-s, -s, t, 0, 2 * Math.PI, !0), e.closePath(), e.fill(), this; },
  resize() { this._width = this._canvas.width, this._height = this._canvas.height; },
  gradient(t) { let i; const a = this._createCanvas(); const e = a.getContext('2d'); const s = e.createLinearGradient(0, 0, 0, 256); for (i in a.width = 1, a.height = 256, t)s.addColorStop(+i, t[i]); return e.fillStyle = s, e.fillRect(0, 0, 1, 256), this._grad = e.getImageData(0, 0, 1, 256).data, this; },
  draw(t) { this._circle || this.radius(this.defaultRadius), this._grad || this.gradient(this.defaultGradient); const i = this._ctx; i.clearRect(0, 0, this._width, this._height); for (var a, e = 0, s = this._data.length; e < s; e++)a = this._data[e], i.globalAlpha = Math.max(a[2] / this._max, void 0 === t ? 0.05 : t), i.drawImage(this._circle, a[0] - this._r, a[1] - this._r); const h = i.getImageData(0, 0, this._width, this._height); return this._colorize(h.data, this._grad), i.putImageData(h, 0, 0), this; },
  _colorize(t, i) { for (var a, e = 0, s = t.length; e < s; e += 4)(a = 4 * t[e + 3]) && (t[e] = i[a], t[e + 1] = i[1 + a], t[e + 2] = i[2 + a]); },
  _createCanvas() { return typeof document !== 'undefined' ? document.createElement('canvas') : new this._canvas.constructor(); },
}, L.HeatRenderer = L.Canvas.extend({ _update() { let t; let i; let a; this._map._animatingZoom && this._bounds || (L.Renderer.prototype._update.call(this), a = this._bounds, t = this._container, i = a.getSize(), a = L.point(a.min.x, a.min.y), L.DomUtil.setPosition(t, a), t.width = i.x, t.height = i.y, t.style.width = `${i.x}px`, t.style.height = `${i.y}px`, this.fire('update')); } }), L.HeatLayer = (L.Layer || L.Class).extend({
  initialize(t, i) { this._latlngs = t, L.setOptions(this, i); }, setLatLngs(t) { return this._latlngs = t, this.redraw(); }, addLatLng(t) { return this._latlngs.push(t), this.redraw(); }, setOptions(t) { return L.setOptions(this, t), this._heat && this._updateOptions(), this.redraw(); }, redraw() { return this._heat && !this._frame && this._map && !this._map._animating && (this._frame = L.Util.requestAnimFrame(this._redraw, this)), this; }, onAdd(t) { this._map = t, this._canvas || (this._renderer = new L.HeatRenderer({ padding: 0 }).addTo(t), this._canvas = this._renderer._container, this._heat = simpleheat(this._canvas), this._updateOptions()), t.on('moveend', this._reset, this), this._reset(); }, onRemove(t) { this._renderer.remove(), this._renderer = null, this._canvas = null, this._heat = null, t.off('moveend', this._reset, this); }, addTo(t) { return t.addLayer(this), this; }, _updateOptions() { this._heat.radius(this.options.radius || this._heat.defaultRadius, this.options.blur), this.options.gradient && this._heat.gradient(this.options.gradient), this.options.max && this._heat.max(this.options.max); }, _reset() { let t = this._map.containerPointToLayerPoint([0, 0]); L.DomUtil.setPosition(this._canvas, t); t = this._map.getSize(); this._heat._width !== t.x && (this._canvas.width = this._heat._width = t.x), this._heat._height !== t.y && (this._canvas.height = this._heat._height = t.y), this._redraw(); }, _redraw() { if (this._map) { for (var t, i, a, e = [], s = this._heat._r, h = this._map.getSize(), n = new L.Bounds(L.point([-s, -s]), h.add([s, s])), r = void 0 === this.options.max ? 1 : this.options.max, h = void 0 === this.options.maxZoom ? this._map.getMaxZoom() : this.options.maxZoom, o = 1 / 2 ** Math.max(0, Math.min(h - this._map.getZoom(), 12)), d = s / 2, _ = [], s = this._map._getMapPanePos(), l = s.x % d, u = s.y % d, c = 0, m = this._latlngs.length; c < m; c++) { var p; var g; var f; const v = this._map.latLngToContainerPoint(this._latlngs[c]); n.contains(v) && (p = Math.floor((v.x - l) / d) + 2, g = Math.floor((v.y - u) / d) + 2, f = (void 0 !== this._latlngs[c].alt ? this._latlngs[c].alt : void 0 !== this._latlngs[c][2] ? +this._latlngs[c][2] : 1) * o, _[g] = _[g] || [], (t = _[g][p]) ? (t[0] = (t[0] * t[2] + v.x * f) / (t[2] + f), t[1] = (t[1] * t[2] + v.y * f) / (t[2] + f), t[2] += f) : _[g][p] = [v.x, v.y, f]); } for (c = 0, m = _.length; c < m; c++) if (_[c]) for (i = 0, a = _[c].length; i < a; i++)(t = _[c][i]) && e.push([Math.round(t[0]), Math.round(t[1]), Math.min(t[2], r)]); this._heat.data(e).draw(this.options.minOpacity), this._frame = null; } },
}), L.heatLayer = function (t, i) { return new L.HeatLayer(t, i); };
